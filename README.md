# PROJECT: POPEMOBILE

## What the heck is this?

A **toolbox** for **answering questions** about the browser-based interactive narrative game **Fallen London**.

Questions such as:

- What is the fastest way to accumulate `Item X`?
- Is `Activity X` more profitable than `Activity Y`?
- What is the expected value of `Carousel X`?


## How to Use

I have vague plans to spin this up into a web app.

Until then, just ping me (or ask ChatGPT) for a guided set-up.

- `main.py` main linear optimization model, to optimize eg. Echoes per Action
    - `player.py` preconfigured player profiles
    - `config.py` constraints, important for menaces and other negative EV qualities
    - `optimization/params.py` optimizer settings, inputs and targets

- `simulations` directory for various monte carlo scripts

### TODO

* Add a license

* Non-action-based items conversion
    * eg. "what's the best way to convert Echoes into Scrip?"
    * model already supports this in theory
    * but I need to figure out a workflow for doing it on the fly

* London Opportunity Deck
    * Figure out WTF to do with this
    * Option 1: Monte Carlo
        * this is what I did with the Upper River deck, and I am happy with the results
            * implement every (economically relevant) card and action in a Monte Carlo sim
            * pick a few representative player profiles as the input parameters
                * eg. the bare minimum F2P, the full BiS whale, and one or two intermediates
            * run the sim for each profile
            * implement the results as single trades
        * challenges:
            * the UR has about 40 cards. London has about 1000.
            * a bunch of cards lead into their own carousels, eg. Arbor
            * red cards with unknown rarities
            * hundreds of bespoke qualities controlling lock/lock, impractical to pick anything that could be called "representative
    * Option 2: Monte Carlo, but only for ultra-thin deck
        * same as above, but remove all the clearly undesirable cards that can be removed
        * much more manageable
    * Option 3: whatever I'm doing right now, where each card has an `Item` exchange, an each `Item._CardDraw` can be trades for a fractional draw of every other card 
        * kind of works?
        * more flexible, in theory
        * harder to translate to human-readable format
            * more "accurate" but less useful?

* London miscellaneous
    * ~~Forgotten Quarter~~
    * Chimes carousels
    * various other early- and mid-game activities

* Laboratory
    * add more workers and experiments to simulation

* Parabola
    * Refine Parabolan War trades
    * Hunts
    * Oneiropomping

* Unterzee
    * Godfall
    * Polythreme
    * various other rarely-visited locations

* Hinterlands
    * Evenlode
        - diving
        - ~~barristering~~
    * Balmoral
        * Clay Highwayman's Camp
        - deciphering
        - ~~clean up Cover Identity model~~
    * Station VIII
        - ~~revisit the Kitchen~~
        - ~~revisit Alchemy~~
    * Moulin
        - add full simulation of Expeditions
        - Monographs, ok for now?
    * Hurlers
        - adulterine castle
        - goat ball
        - digging
        - other discordance stuff
    * Marigold
        - anything besides the knights thing?

* TLC

* Lots more things

### Out of Scope

* Heart's Game strategy

## Other FAQs
### Q: Is this README up-to-date with the actual code?

A: almost certainly not

### Q: How do I change the optimization target?

A: change the value in `optimization/params.py`

### Q: How do I tweak this other parameter?

A: it's probably in there somewhere

### Q: Why did you...

A: it seemed like a good idea at the time

### Q: The way you did this thing looks weird.

A: yes

### Q: I read all your code and it more or less makes sense

A: DM me, let's be friends

---

## AI-Generated Documentation

Below is comprehensive documentation generated by AI for the main components of the system.

### Project Overview

The Fallen London Optimization Tool is a Python-based system that helps players find optimal paths for converting actions and resources into desired outcomes in the game Fallen London. The system uses linear programming to optimize trade paths and provides visualizations to help understand the results.

### About the Optimization Engine

The optimization engine uses scipy's linear programming solver (linprog) to find optimal trade paths in the game. The solver:

1. Creates a linear programming model from trade definitions
2. Uses the 'highs' method for efficient solving of large-scale problems
3. Handles constraints and bounds on variables
4. Supports L1 regularization for sparsity in trade paths

The optimization model is formulated as:
- Objective: Maximize the target resource output
- Constraints: Resource limits and trade requirements
- Variables: Trade quantities and resource flows

The solver provides:
- Optimal trade quantities
- Marginal values for constraints
- Slack variables for unused resources
- Efficiency metrics for trade paths

### Core Components

#### 1. Main Entry Point (`main.py`)

The main entry point provides the core functionality for running the optimization system, including:
- Module registration for different game mechanics
- Configuration management
- Main execution flow
- Error handling and logging

Key classes:
- `ModuleRegistry`: Manages trade modules and their registration
- `setup_registry()`: Initializes and registers all available trade modules
- `main()`: Orchestrates the optimization process

#### 2. Configuration Management (`optimization/config_manager.py`)

The configuration system handles:
- Loading and saving optimization parameters
- Managing default configurations
- Handling user-defined settings
- Managing player qualities and constraints

Key classes:
- `OptimizationConfig`: Dataclass for optimization parameters
- `ConfigManager`: Manages configuration loading and saving

#### 3. Optimization Engine (`optimization/model_runner.py`)

The optimization engine provides:
- Linear programming model creation and solving
- Trade network visualization
- Resource flow analysis
- Efficiency metrics calculation

Key features:
- Model creation from trade definitions
- Constraint handling
- Solution processing
- Visualization generation

### Trade Modules

The system supports various trade modules organized by game location:
- Core modules (time_the_healer, social_actions, etc.)
- London modules (newspaper, laboratory, etc.)
- Upper River modules (exchange, gardens, etc.)
- Firmament modules (hallows_throat, midnight_moon, etc.)
- Special modules (bone_market, rat_market, etc.)

### Visualization System (Planned)

The system is designed to support three types of visualizations (not currently implemented):
1. Trade Network Graph
   - Shows relationships between resources
   - Edge weights represent resource flows
   - Helps understand trade paths

2. Resource Flow Diagram
   - Shows flow of resources through trades
   - Positive flows represent outputs
   - Negative flows represent inputs

3. Efficiency Metrics Chart
   - Shows efficiency of different trades
   - Output resource per input resource
   - Helps identify most efficient trades

Currently, the system provides text-based output through the `display_summary` method, which shows:
- Trade paths and their marginal values
- Resource gains and losses
- Efficiency metrics
- Surplus and unused items

### Error Handling and Logging

The system includes comprehensive error handling and logging:
- Module-level logging configuration
- Error tracking for module registration
- Optimization error handling
- Visualization error handling

### Configuration Example

Example configuration file (`config.json`):
```json
{
    "optimize_input": "Action",
    "optimize_output": "Echo",
    "actions_per_day": 120,
    "cards_per_day": 40,
    "story_qualities": {
        "BagALegend": 4000,
        "SetOfCosmogoneSpectacles": 1
    },
    "fate_qualities": {
        "AcquaintanceTheClamorousCartographer": 6
    },
    "core_constraints": {
        "Action": 840,
        "CardDraws": 280
    }
}
```

### Adding New Trade Modules

To add a new trade module:
1. Create a new module in the appropriate directory
2. Implement the `add_trades(config)` function
3. Register the module in `main.py`

Example:
```python
# my_module.py
from config import Config

def add_trades(config: Config):
    """Add trades for my module"""
    config.add({
        "Input": -1,
        "Output": 2
    })
```